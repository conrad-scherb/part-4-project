%j = yes
%k = no
%
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%
%FACTOR_SIGNAL = 1.5; % 49 to 65
%FACTOR_SIGNAL = 2.0; % 66 to 69
%FACTOR_SIGNAL = 2.5; % 70, 71 ... 101

%Listing Response Data
clear resp
%           xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
resp{49} = 'kkkjkkkkkjjkjkkkjkjkkkkjkjjkjjjjjjjkjkkk';
resp{50} = 'kkkjjjkjjjjjjkkkkjkkjjjjkkkjjkkjjkjkkjkj';
resp{51} = 'jjjkjkkjkjkkkkjkkkjjjjjkkkjkkkkjjjkjjkkj';
resp{52} = 'jkkkjjkkkkkjjkkjjkkjjkjkjjkkjkkkkkkjjkkk';
resp{53} = 'jkjkkjkkkkkjkjkjkjkkjkjkkkkkkkkkjkjkjkkk';
resp{54} = 'jkkkjkjkkkkkjjjkkjkkjkkkjkjkjkkjkkjkkjjk';
resp{55} = 'jkjkjkjjkkkkjjkkjkkjkkjkjjjjkkkkkjkjjjjk';
resp{56} = 'jkjjkjkjkkkkkkjjkkjkkkkkkkkkjkjjjkjkkkjk';
resp{57} = 'kjjjkjjjkkjkkjkjkkkkkkjjjkjkjjjkjjjkjjkj';
resp{58} = 'kkkkjjkkkkjkjkkkkjkkjkkjkjkkkjjjkkkjjjjk';
resp{59} = 'jkkkkkkkkkjjjjkkjkkjjjkkkjjkjkjkjkjjjjkk';
resp{60} = 'jjjjjjkjkkkjkjkjkkjjjkkjjjjkkjjkjjjjjjjk';
resp{61} = 'jjkkkjjkkkjkkkkjkkjkkkjjjjkjkkjjjkkjkjkj';
resp{62} = 'jkkjjjkkjkkjkkjkjkkkkkkjjjkjkjjkkjjkjkjk';
resp{63} = 'jjkkjkkjkjjjkjjkkjkkkjkkjkjjjjjkkkkkkkjk';
resp{64} = 'jjkkjkkjjjjjkjjkkjkkkjkjjkkjjjkjkkkjkjkj';
resp{65} = 'kkkkjjkjkkjjjkjkjkkkjkjjkkjjkjkjjjkjjkkj';
resp{66} = 'jkjjkjjkjkjkkjkkkkjkkkkkjkjkjjjkjjjjjjjk';
resp{67} = 'jjkkjkkjkkkjkkkkjkkjkjjkkjjkjjjkkjkkjjkk';
resp{68} = 'jkjjjkkkkjkkjjjkjkkkkjjjkjjkjjkjjkkjjjjk';
resp{69} = 'jjkjkkkjkjkjkkkkkkjkjjjjjjjjkkjkkjkkjkjk';
resp{70} = 'kjjkjjkjjjjjjkkkkkkkkjkjkkjjkkjkkjkkjjkj';
resp{71} = 'jjkkkkkjkjkjkkkkkjjkjjjkkkjkjkkkkkkjkkkj';
resp{72} = 'kkkkkkjjkjjjjkkkjjjkkjjkkjkjkjkjjjkjjjkk';
resp{73} = 'jkjjkkjjjkjkkkkjkkjjkkjkjjkkkjjjkjkkjkjk';
resp{74} = 'jjjjjkkkjkkjkjkkkjjjjkkjkkkjjkjkkjkjkkkj';
resp{75} = 'jkjkkjkkjjkkkkjjkjkjkkkkkkkkkjkjjkkkkjkk';
resp{76} = 'jkkjkkjkkkkkkjkkkkkkjjjkkjjjjkkkkkjjkjjk';
resp{77} = 'jkjkkkkjkjkkjjjkjkjkkkjkkjkjjjkkjkjjkkkk';
resp{78} = 'jjjjkjjkjjkjkkjkkkkkkkkjkjjjkjkkkkkjjkkk';
resp{79} = 'jjkkkkkkkjkkjkkkjkkkjkjkjjjkkkkjkkkjjkkj';
resp{80} = 'jjjjkjjkjkjkkjkkjkkkkjkjkkjkjkkjkjkkkjjk';
resp{81} = 'jkkkjjkkjkkjkjjkjkjjkkjkjjjjkkjkkkjkkjkk';
resp{82} = 'jjjkkkkjjjkjkjjkkjjkjkjkjjjkkjkjjjkkjkjk';
resp{83} = 'jkjjjkkjkjkjjjkkjkjjkjkkjkjkkjjjjjkkkjkk';
resp{84} = 'jjkjkkkkjkjkjkkjkkkkkkjkkjkjjkkkjkjjjjkj';
resp{85} = 'kjkjjkjkjkkkkjkjkkkkjjkkkkkkkkkjkjkjjkjk';
resp{86} = 'jjkkkkkkkkjkjkkjkjkkkkkjkkjjjjkjjjjkkkkj';
resp{87} = 'kjjkkjkjkkkkkkjkjkjjjjkjkjjkjjkjjjkkjkkk';
resp{88} = 'kkjjkjjkkjjkjkjkkjkkjkjjkjkjjjkkkjkkkkkj';
resp{89} = 'jjjkjkkjkkjjkjkjjkkjkkjkjkkkkkjjkkjkkkjk';
resp{90} = 'jjjjkkkkkkjjjkkjjjjkkjkkjkkkkkjkkkkjkjjj';
resp{91} = 'jjkkkkkjkkkkkkkkkkjkjkjjjjkjkjjkkjjkjjjj';
resp{92} = 'jjkjkkjkkkkjkkkjkjjjjkkjkjkkjjjkkjkkkjkj';
resp{93} = 'jkjjjkjjjkjkkjkkkkkkjjkkjkkjjkkjkkkjjjjj';
resp{94} = 'jkkkjkkjkkkjjkjkjkkjjkjkkkjkkkjkkkkkjkkk';
resp{95} = 'jkjkjjkjjjkjkjkkkkkjjkkjkjkkkkjkkkkkkjjk';
resp{96} = 'jjkjjjkjjkjkkjkkkjkkjjjkjkjkkkjjkkjjkjjk';
resp{97} = 'kjjjjjjjkkjkjkkjkkjjjkkkkjjkkjjkkjkkkkkk';
resp{98} = 'jjjjjkjkkjjjkkkjkjjkjjkjjkkjjkkkjkjkkkkj';
resp{99} = 'kkjkkkjkkkkkjjjjjkjkjkkkkkjjkkjjkjkkjjkk';
resp{100} = 'jkkjjjkkjkkjjjkjjjkjkkkkkkkjkjjjkjkjjkkk';
resp{101} = 'kjkkkjkjkkkkjjjkjkkkkkjjjkkjjkkjkjkkjkjj';
resp{102} = 'jjkkkkjjkkkkkjjkjjkjjkkkkjkkkjjjkkjjjkjj';
resp{103} = 'kjkkjjjjjjkjjjjjkkkjkkjkkjjjkjkkkkkkkjjk';
resp{104} = 'kjjjjjkkjkkkkkjkkkjjkkjkjkjjjkjkjjjjjkkk';
resp{105} = 'kkjjjkjkkkkkkjjkkjkkjkkkjkjjkkkjkjkjjkkk';
resp{106} = 'jkkkjjjkkjjkjkjjkjjkjjkjkkjjjjjkjjkjkkkj';
resp{107} = 'jkkjkjjjkkjkkjjjkjkkkkkkjkkkkkkkjkjkjjjj';
resp{108} = 'kkkjjkkjkkkjjjkkjkkjkjjkkjjkjjjjjjkjjkkk';
resp{109} = 'jjkjjkkjjjkkjkkjjjjjkjkkkjjkkkjkkjkkjkkk';
resp{110} = 'kjjkjkjkkkkjjkkkkjjkkjjjkjkkjkkjjkkjkjkk';
resp{111} = 'kjjkkkkkkkjjkkjjkjkkjkjjkjkjkkjkjjkkkkjk';

%Functions for converting complex numbers into degrees 
fnAngle2UnitComplex = @(x_deg) complex(cos(x_deg/180*pi), sin(x_deg/180*pi));
fnDoubleTheta = @(z) abs(z).*fnAngle2UnitComplex(2*angle(z)/pi*180);

%Loop which goes through and classifies all of the data
dsgNoiseByType = {[];[];[];[]};
for iiblock = 49:111

  resp_ = resp{iiblock};
  resp__ = [];
  dsgYN = [];

  for iitrial = 1:length(resp_)

% Y and N; one per trial comprising this block (probably 20).
    dsgYN_ = dlmread(sprintf('/Users/luke/ori_time/stimuli/designYN_%d_%d',iiblock,iitrial));
    dsgYN = [dsgYN dsgYN_];

% Vector resp__ contains 0 (response = no) and 1 (yes)
    resp__ = [resp__ 0];
    if (resp_(iitrial) == 'j'), resp__(end) = 1; end

% There are 4 types of response: hit, miss, CR, FA.
    if ((resp__(end) == 1) && (resp__(end) == dsgYN(iitrial))), this_type = 1; end
    if ((resp__(end) == 0) && (resp__(end) ~= dsgYN(iitrial))), this_type = 2; end
    if ((resp__(end) == 0) && (resp__(end) == dsgYN(iitrial))), this_type = 3; end
    if ((resp__(end) == 1) && (resp__(end) ~= dsgYN(iitrial))), this_type = 4; end

    dsgSig = dlmread(sprintf('/Users/luke/ori_time/stimuli/signal_%d_%d',iiblock,iitrial));
    dsgSigPlusNoise_ = dlmread(sprintf('/Users/luke/ori_time/stimuli/signal_plus_noise_%d_%d',iiblock,iitrial));
    dsgSigPlusNoise = dsgSigPlusNoise_(5,:); % middle frame of 9
    dsgNoise_ = dlmread(sprintf('/Users/luke/ori_time/stimuli/noise_%d_%d',iiblock,iitrial));
    dsgNoise = dsgNoise_(5,:); % middle frame of 9

    oriSig_deg = angle(dsgSig(1))/pi*180;
    if (dsgYN(iitrial) == 0), oriSig_deg = 0; end
    for jj = 1:64 
      dsgSigPlusNoise(jj) = fnAngle2UnitComplex(angle(dsgSigPlusNoise(jj))/pi*180 - oriSig_deg);
      dsgSig(jj) = fnAngle2UnitComplex(angle(dsgSig(jj))/pi*180 - oriSig_deg);
      dsgNoise(jj) = fnAngle2UnitComplex(angle(dsgNoise(jj))/pi*180 - oriSig_deg); %
    end

%figure; hold on
%subplot(8,8,1)
%for jj = 1:64
%  subplot(8,8,jj); hold on
%  plot([0 real(dsgSig(jj))],[0 imag(dsgSig(jj))],'-k'); axis square; axis(1.1*[-1 1 -1 1]);
%  plot([0 real(dsgNoise(jj))],[0 imag(dsgNoise(jj))],'-r'); axis square; axis(1.1*[-1 1 -1 1]);
%  set(gca, 'xtick', [-100 100], 'ytick', [-100 100]);
%end

    %dsgNoiseByType{this_type} = vertcat(dsgNoiseByType{this_type}, fnDoubleTheta(dsgSigPlusNoise));
    dsgNoiseByType{this_type} = vertcat(dsgNoiseByType{this_type}, fnDoubleTheta(dsgNoise));

  end % iitrial

% Overall accuracy for block.
  resp___ = resp__ == dsgYN;
  sum(resp___)

end % iiblock

%%%
% There are 4 types of response: hit, miss, CR, FA.
%%%%%
va = mean(dsgNoiseByType{4},1) + mean(dsgNoiseByType{1},1) - mean(dsgNoiseByType{2},1) - mean(dsgNoiseByType{3},1);
fnIsotropics = @(x) cos(x) + i*sin(x);
BOOT = 1000;
Bva = zeros(BOOT,length(va));
for iiboot = 1:BOOT
  aa = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{1}))-0.5));
  bb = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{2}))-0.5));
  cc = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{3}))-0.5));
  dd = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{4}))-0.5));
  Bva(iiboot,:) = mean(dd,1) + mean(aa,1) - mean(bb,1) - mean(cc,1);
end

vaz = zeros(1,length(va));
for jj = 1:64
  vaz(jj) = (abs(va(jj)) - mean(abs(Bva(:,jj)))) / std(abs(Bva(:,jj)));
end

figure; hold on
IX = [19:22 27:30 35:38 43:46];
for jj = IX
  subplot(8,8,jj); hold on
  plot(0,0,'+k');
  this_wid = 1;
  if (vaz(jj) >= 2), this_wid = 2.0; end
  plot([0 real(va(jj))],[0 imag(va(jj))],'-k','LineWidth',this_wid); axis square; axis image; axis(0.5*[-1 1 -1 1]);
  set(gca, 'xtick', [-100 100], 'ytick', [-100 100]);
  text(min(xlim)+0.1, max(ylim)-0.1, sprintf('%.2f', vaz(jj)))
end
%%%%%%

%%%
% Variance. There are 4 types of response: hit, miss, CR, FA.
%%%%%%
vv = var(dsgNoiseByType{4},1) + var(dsgNoiseByType{1},1) - var(dsgNoiseByType{2},1) - var(dsgNoiseByType{3},1);
Bvv = zeros(BOOT,length(vv));
for iiboot = 1:BOOT
  aa = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{1}))-0.5));
  bb = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{2}))-0.5));
  cc = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{3}))-0.5));
  dd = fnIsotropics(pi*2*(rand(size(dsgNoiseByType{4}))-0.5));
  Bvv(iiboot,:) = var(dd,1) + var(aa,1) - var(bb,1) - var(cc,1);
end

vvz = zeros(1,length(vv));
for jj = 1:64
  vvz(jj) = (abs(vv(jj)) - mean(abs(Bvv(:,jj)))) / std(abs(Bvv(:,jj)));
end

figure; hold on
IX = [19:22 27:30 35:38 43:46];
for jj = IX
  subplot(8,8,jj); hold on
  plot(0,0,'+k');
  this_wid = 1;
  if (vvz(jj) >= 2), this_wid = 2.0; end 
  plot([0 real(vv(jj))],[0 imag(vv(jj))],'-k','LineWidth',this_wid); axis square; axis image; axis(0.08*[-1 1 -1 1]);
  set(gca, 'xtick', [-100 100], 'ytick', [-100 100]);
  text(min(xlim)+0.1, max(ylim)-0.1, sprintf('%.2f', vvz(jj)))
end
%%%%%%

%%%
% Covariance. There are 4 types of response: hit, miss, CR, FA.
%%%%%%



fnInPr = @(z1,z2) real(z1).*real(z2) + imag(z1).*imag(z2);
IX = [19:22 27:30 35:38 43:46];

mtxip = {[];[];[];[]};
for resp_type = 1:4
  mtxip{resp_type} = zeros(length(IX),length(IX));
  AA = [dsgNoiseByType{resp_type}(:,IX)];
  for iirow = 1:length(IX)
    for iicol = 1:length(IX)
      mtxip{resp_type}(iirow,iicol) = mean(fnInPr(AA(:,iirow) - mean(AA(:,iirow),1), AA(:,iicol) - mean(AA(:,iicol),1)));
      %mtxip(iirow,iicol) = mean(fnInPr(AA(:,iirow), AA(:,iicol)));
    end
  end
end
mtxip_ = mtxip{1} + mtxip{4} - mtxip{2} - mtxip{3};


fnShuffle = @(x) x(randperm(length(x)));
fnPop16 = @(x) x(1:16);
BOOT = 500;
Bmtxip_ = zeros(size(mtxip_,1), size(mtxip_,2), BOOT);
for iiboot = 1:BOOT

  BIX = fnPop16(fnShuffle(setdiff(1:64, IX)));
  Bmtxip = {[];[];[];[]};
  for resp_type = 1:4
    Bmtxip{resp_type} = zeros(length(BIX),length(BIX));
    AA = [dsgNoiseByType{resp_type}(:,BIX)];
    for iirow = 1:length(BIX)
      for iicol = 1:length(BIX)
        Bmtxip{resp_type}(iirow,iicol) = mean(fnInPr(AA(:,iirow) - mean(AA(:,iirow),1), AA(:,iicol) - mean(AA(:,iicol),1)));
      end
    end
  end
  Bmtxip_(:,:,iiboot) = Bmtxip{1} + Bmtxip{4} - Bmtxip{2} - Bmtxip{3};

end

zmtxip_ = 0*mtxip_;
for iirow = 1:size(mtxip_,1)
  for iicol = 1:size(mtxip_,2)
    zmtxip_(iirow,iicol) = (mtxip_(iirow,iicol) - mean(Bmtxip_(iirow,iicol,:))) / std(Bmtxip_(iirow,iicol,:));
  end
end

triu(zmtxip_,1) .* double(abs(triu(zmtxip_,1)) > 2)

%fnPop2 = @(x) x(1:2);
%BB = [dsgNoiseByType{resp_type}(:,[1:16 49:64])];
%BOOT = 500;
%Bstat = zeros(1,BOOT);
%for iiboot = 1:BOOT
%  ix = fnPop2(randperm(32));
%  Bstat(iiboot) = median(fnInPr(BB(:,ix(1)) - mean(BB(:,ix(1)),1), BB(:,ix(2)) - mean(BB(:,ix(2)),1)));
%end
%figure; hold on
%hist(Bstat, 20); axis square
%[mean(Bstat); std(Bstat)]
%otDrawCovMtx(mtxip, 2*std(Bstat))
%mtxipz = (mtxip - mean(Bstat)) / std(Bstat)
%triu((abs(mtxipz) > 1.96) .* mtxipz,1)

